# Interop between RenderDSL and F# Dialect Components

Components in the two worlds are fully interoperable.

## Using F# components in .render files

From inside `.render` files, you can use the standard XML syntax to construct
components. The only difference is that you need to have the `rt-fs='true'`
attribute to tell the system that it's an F# dialect component (that doesn't have
the system generated parameters). E.g.

```xml
<Link rt-fs='true' HubId='hub.Id'/>
<ActionButton rt-fs='true' hub='hub'/>
```

Another way, which should only be used if the above way doesn't work,
is to use our regular `{= ...}` syntax:

```xml
{= Ui.Route.Hub.Allocator.Shipments maybeGrouping}
```

this is identical to

```xml
<Route.Hub.Allocator.Shipments rt-fs='true' maybeGrouping='maybeGrouping'/>
```

The XML syntax should probably be preferred for the sake of consistency with the
rest of the `.render` file. It's also robust against the use of braces inside the
attributes. E.g.

```xml
{= Ui.SomeComponent (onPress = (fun value -> form.UpdateAcc { acc with SomeValue = value }) }
```

This will fail, because the compiler will get confused by the `}` character. In XML, this would
work just fine:

```xml
<Ui.SomeComponent rt-fs='true' OnPress='fun value -> form.UpdateAcc { acc with SomeValue = value }'/>
```

## Using RenderDsl based components in F#&nbsp;

All RenderDsl based components have a constructor function automatically generated
based on the props defined in `typext.fs` file. Each prop in the `Props` type will have
a corresponding `camelCased` parameter generated in the constructor function, along with
some optional system level parameters that you can for the most part ignore.

The constructor function for a given component can be found in the lib/app's "alias" namespace,
defined in `eggshell.json`. For apps, this is always set to `Ui`, and for libs, it is typically
the name of the lib sans the "Lib" prefix, e.g. `LibSubjectUi` becomes `SubjectUi`. The only
exceptions are `LibClient`, which is aliased to `LC`, `LibRouter` aliased to `LR`, and `ReactXP`
which is aliased to `RX`.

Here's an example of invoking the `Button` component from `LibClient`:

```fsharp
LC.Button (
    label = "Audit Log",
    level = Button.Level.Secondary,
    state =
        Input.ButtonHighLevelStateFactory.MakeGo (
            Admin (AdminRoute.PackageAudit packageId),
            nav
        )
)
```

You will need to have `open LibClient.Components`, or the corresponding `open` for whatever
lib/app you're using.

Here's an examle of using a component defined within your app:

```fsharp
Ui.ChildCard (
    position = position,
    ?onPress = (if isLocked then None else Some (nav.Go (PickAction (stationId, shipmentId, shipmentTaskId, pickLocation, shouldDisplayShelfZoneName)))),
    children = [
        Ui.ThingToPick (pickLocation, shouldDisplayShelfZoneName, assignedThingRequests)
    ]
)
```

## Edge cases

Sometimes, when doing some low level programming, it is necessary to interact with
the system level parameters of the autogenerated constructor functions.

In particular, handling of the `children` props is tricky. At call site, i.e. component
construction site, it's most preferable for `children` to be of type `List<ReactElement>`,
because more often than not you have multiple children, and even when you have just one,
wrapping it in square brackets is far less invasive than the contrary, which is wrapping
the whole thing in `asFragment` to make a single element out of a list. But at runtime,
the `children` prop is actually typed as `ReactElement`. It's quite a mess to reconcile
between the two, especially if interaction with raw React (which cannot consume F# lists,
but needs to work with JS arrays) is involved. So sometimes we need to do things like this:

```fsharp
type Ui with
    [<ReactComponent>]
    static member AppContext(children: ReactChildrenProp) =
        LR.Router ([
            LC.AppShell.Context(xLegacyChildren = children, children = [noElement]) // legacy takes precedence
        ])
```
