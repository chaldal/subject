Data Ownership and Different Types of State

Pstate is "persistent state". Estate is "ephemeral state".

The guideline for choosing whether a certain piece of data should be put in pstate or estate is as follows:

Imagine we're doing server-side rendering, and the app needs to be rehydrated from pstore when it makes it over the wire to the user's browser. Data that was put on pstate will be in pstore. Data that was put in estate will not be. So when deciding where to put the data, ask yourself "is this ephemeral state, i.e. it's okay for an app to lose it on rehydration, or is not, i.e. the data backs some non-ephemeral part of the UI?"

A classic example of ephemeral state is the `isOpen` state for a dropdown menu. What the user is currently hovering and whether the menu is open or not doesn't need to survive rehydration. Same for things like in-flight form input — it's unlikely that there's a good reason for it to be on pstate.


In deciding where data belongs in a component tree, a number of competing priorities arise:

* Preference for dumb, stateless components. The simpler any system is, the more robust and bug-free it is. In React land, pure stateless components are the simplest building block, and we should thus strive to build our UIs as much as possible from these.

* Default deny, and keeping private things private. In some ideal sense, if a component needs to keep track of some state, nobody should ever need to know about this. The type of the State record should be private (it isn't because of implementation constraints). Having a parent component maintain your state for you is in general not desirable, since it pushes private concerns of the given component up the component tree.

* Single source of truth for data. We must be careful that any data has a single source of truth within our systems.

* Persistence in pstore. Given the way our persistence store layer is designed, each pstateful component needs a pstorekey. Routes and dialogs get one auto-generated by the system, but any other pstateful components need one derived from their parent route or dialog's key. In general, there is very rare a need to have pstateful components other than routes and dialogs.

* Data subscription + fire-and-forget actions. As per the guideline above, service-originating data (list of users, health status of servers, shopping cart, etc) should live on pstate. In our system, this effectively means that it should live on pstate of routes or dialogs. This does not mean, however, that actions upon this data also need to live on this top level components. They could, but we'd have to pay the cost of plumbing them down all the way down the component tree to the leaf components that finally attach them to the OnPress events. This cost extra plumbing, and gains us nothing, because our actions are designed to be fire-and-forget in style, i.e. they return `Async<unit>` or `Async<SuccessStatus>` to potentially power `inProgress` indicators, but _never_ `Async<UpdatedData>`, since data only flows in one direction — the updated data will be given to the route's subscription when it is available after the action completes.


So, with these competing priorities in mind, here are some guidelines of what to put on what kind of state:

* service-bound data goes on pstate and gets passed down the tree through props
* fire-and-forget service actions get implemented in the component that requires it
  * actions should never have business logic in them, that belongs in the service
  * there are plenty of architectural scenarios when passing actions/functions is totally valid
* ephemeral state like "is the dropdown open" or "is something in progress" belongs on the estate of the component that's the clear owner (exercise default-deny)
* pstateful components should only concern themselves with loading data and passing it to other components that do actual rendering
* if your estateful component is doing more than a trivial amount of work, split it into two — a state managing component with close to no UI, and a stateless component that renders the UI