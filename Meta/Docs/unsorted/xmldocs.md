# XmlDocs

To power the gallery component samples feature, we originally wrote
a series of `Contents.Whatever` components, one for each standard
library component that we wanted to show off. They looked something
like this:

```xml
<ComponentContent DisplayName='"Buttons"' Props='~ForFullyQualifiedName "LibClient.Components.Buttons"'>
    <rt-prop name='Samples'>
        <ComponentSample>
            <rt-prop name='Visuals'>
                <LC.Buttons rt-fs='true' Align='~Left'>
                    <LC.Button
                     Icon='~Left Icon.Home'
                     Label='"Home"'
                     State='^LowLevel (~Actionable Actions.greet)' />
                    <LC.Button
                     Icon='~Left Icon.Submit'
                     Label='"Submit"'
                     State='^LowLevel (~Actionable Actions.greet)' />
                </LC.Buttons>
            </rt-prop>
            <rt-prop name='Code |> ~singleBlock ~Render'><![CDATA[
                <LC.Buttons rt-fs='true' Align='~Left'>
                    <LC.Button
                        Icon='~Left Icon.Home'
                        Label='"Home"'
                        State='^LowLevel (~Actionable Actions.greet)' />
                    <LC.Button
                        Icon='~Left Icon.Submit'
                        Label='"Submit"'
                        State='^LowLevel (~Actionable Actions.greet)' />
                </LC.Buttons>
            ]]></rt-prop>
        </ComponentSample>

```

Some of them needed helper types/values (like the `Actions.greet` you see above)
in order to show off the components properly. Those would typically live inside the
`Contents/Whatever/Whatever.typext.fs` file.

Then somebody had a brilliant idea: "Can we somehow use dotnet's XmlDocs feature to
power the gallery? That way, we'd be able to both see example code in the IDE when
we hover the component's function name, and see the samples in action in the gallery
like we do now". We prototyped it, and it seems to work pretty well. It looks
something like this:

```fsharp
    /// <summary>Wrap the child in a fixed size box</summary>
    /// <param name="child" type="ReactElement"/>
    /// <param name="width" type="int" default="None"/>
    /// <param name="height" type="int" default="None"/>
    /// <param name="styles" type="array&lt;ViewStyles&gt;" default="[||]"/>
    /// <example>
    /// Basics
    /// <code>
    ///     LC.Sized (
    ///         width = 100,
    ///         height = 100,
    ///         child = RX.View (
    ///             styles = [|Styles.greyExpandingBox|],
    ///             children = [|LC.Text "the box"|]
    ///         )
    ///     )
    /// </code>
    /// </example>
    ///
    /// <example>
    /// Only width
    /// <code>
    ///     LC.Sized (
    ///         width = 100,
    ///         child = RX.View (
    ///             styles = [|Styles.greyExpandingBox|],
    ///             children = [|LC.Text "the box"|]
    ///         )
    ///     )
    /// </code>
    /// </example>
    ///
    /// <example>
    /// Only height
    /// <code>
    ///     LC.Sized (
    ///         height = 100,
    ///         child = RX.View (
    ///             styles = [|Styles.greyExpandingBox|],
    ///             children = [|LC.Text "the box"|]
    ///         )
    ///     )
    /// </code>
    /// </example>
    ///
    /// <remarks>
    ///     Setup code
    ///     <code setup="true">
    ///         module private Styles =
    ///             let greyExpandingBox = makeViewStyles {
    ///                 backgroundColor Color.DevLightGrey
    ///                 flex 1
    ///             }
    ///     </code>
    /// </remarks>

    [<Component>]
    static member Sized (?child: ReactElement, ?width: int, ?height: int, ?styles: array<ViewStyles>) : ReactElement =
        // the actual body of the Sized component
```

A few things to note here:

* XmlDocs will check the name for the `<param>` tags, but the `type` and `default` fields are our own, whether they
  match the actual declared parameters is not checked, and they are used to power the gallery.

* Any code inside the `<remarks><code setup="true">...</code></remarks>` section becomes module level code for all the
  examples for this component.

* To scrape these comments and generate the `Components/ScrapedXmlDocsBasedContents/LC.fs` file, and others if we eventually
  enable this for other libs, you need to run the `scrape.sh` in `AppEggShellGallery/scraping`

* Since the comment in these comments becomes real F# code in the gallery, it needs to compile.

* There are situations where a namespaced component name is generated by the XmlDocs system in a lossy manner, i.e. it's
  impossible to recover the original component's name (as we'd like to show it to the gallery viewer) in a way that we'd
  like. For these cases, `XmlDocs.fs` has a `lossyNameMappings` value where you can add such components.

* To hook up the gallery's component display pages to this system, we do this in `AppEggShellGallery/src/Components/Route/Components/Components.render`:

```xml
<rt-case is='Input_Picker'><Content.Input.Picker                      /></rt-case>
<rt-case is='InProgress'  ><XmlDocsContent.LC.InProgress  rt-fs='true'/></rt-case>
```

The first line is the old way doing things, the second line is the XmlDocs based way.
