import { Seq, Try, Option, Some, None } from "eggshell-lib-lang-typescript";
import * as path from "path";
import * as fs from "fs"

export interface RootConfig {
    type: 'repoRoot';
}

export interface EggShellProjectConfigCommon {
    name:  string;
    alias: string;
    renderDependencies: Seq<string> | undefined;
    render: {
        dependenciesToRtCompile: Seq<string> | undefined;
        additionalModulesToOpen: Seq<string>;
        componentLibraryAliases: Seq<[string | 'default', string]>;
        componentLibraryPaths:   Seq<[string, string]>;
        componentAliases:        Seq<[string, string]>;
    } | undefined
}

export interface AppConfig extends EggShellProjectConfigCommon {
    type: 'app';
    buildDev?: {
		copyStaticFiles: Seq<[string, string]>;
	},
    build: {
        copyStaticFiles: Seq<[string, string]>;
    }
}

export interface LibraryConfig extends EggShellProjectConfigCommon {
    type: 'library';
}

export type ProjectConfig = AppConfig | LibraryConfig | RootConfig



export interface RootProject {
    type:          'repoRoot';
    config:        RootConfig;
    rootPath:      string;
    templatesPath: string;
}

export interface EggShellProjectCommon<ConfigType> {
    config:            ConfigType;
    rootPath:          string;
    srcPath:           string;
    componentsPath:    string;
    autogeneratedPath: string;
}

export interface AppProject extends EggShellProjectCommon<AppConfig> {
    type:          'app';
    buildRootPath: string;
    buildPath(target: BuildTarget, step: BuildStep): string;
    entryFileNameWithoutExtension: string;
}

export interface LibraryProject extends EggShellProjectCommon<LibraryConfig> {
    type: 'library';
}

export type Project = RootProject | AppProject | LibraryProject

// NOTE I'm really struggling for a name here, this union type is for "apps and libs
// that are built on this stack", as distinct from the "repo root". Part of the problem
// is that the repo root isn't strictly a project, but the way we generalized the
// eggshell.json file unfortunately makes it such, and fixing that is too much
// refactoring.
export type EggShellProject = AppProject | LibraryProject

export declare type BuildTarget = 'web' | 'native';
export declare type BuildConfig = 'dev' | 'package';
export declare type BuildStep = 'fable' | 'commonjs' | 'bundle' | 'final';

export function loadClosestUptreeProject(directory: string): Try<Option<Project>> {
    const expectedConfigPath = path.join(directory, "eggshell.json");
    if (fs.existsSync(expectedConfigPath)) {
        return loadProject(directory);
    }
    else {
        const parentDirectory = path.resolve(directory, "..");
        // rather odd behaviour, but apparently "/" === path.resolve("/", "..")
        if (parentDirectory === directory) {
            return Try.failure("Got to file system root without finding eggshell.json")
        }
        else {
            return loadClosestUptreeProject(parentDirectory);
        }
    }
}

function loadProject(directory: string): Try<Option<Project>> {
    const expectedConfigPath = path.join(directory, "eggshell.json");
    if (fs.existsSync(expectedConfigPath)) {
        const contents = fs.readFileSync(expectedConfigPath).toString()
        try {
            const parsedConfig: ProjectConfig = JSON.parse(contents);
            let project: Project;
            switch (parsedConfig.type) {
                case 'repoRoot': project = {
                        type:          'repoRoot',
                        config:        parsedConfig,
                        rootPath:      directory,
                        templatesPath: path.join(directory, "Meta", "LibScaffolding", "templates"),
                    }
                    break;
                case 'app': project = {
                        type:              'app',
                        config:            parsedConfig,
                        rootPath:          directory,
                        srcPath:           path.join(directory, "src"),
                        componentsPath:    path.join(directory, "src", "Components"),
                        autogeneratedPath: path.join(directory, "src", "_autogenerated_"),
                        entryFileNameWithoutExtension: "Bootstrap",
                        buildRootPath:     path.join(directory, ".build"),
                        // Build path must be kept in sync with Fake/Constants.fsx
                        buildPath(target, step) {
                            return path.join(this.buildRootPath, target, step);
                        }
                    }
                    break;
                case 'library': project = {
                        type:              'library',
                        config:            parsedConfig,
                        rootPath:          directory,
                        srcPath:           path.join(directory, "src"),
                        componentsPath:    path.join(directory, "src", "Components"),
                        autogeneratedPath: path.join(directory, "src", "_autogenerated_"),
                    }
                    break;
            }
            return Try.success(Some(project));
        }
        catch (e) {
            return Try.failure(e);
        }
    }
    else {
        return Try.success(None);
    }
}

export function getRepoRootProject(currProject: Project): Try<RootProject> {
    return getRepoRootProjectHelper(currProject)
}

function getRepoRootProjectHelper(currProject: Project): Try<RootProject> {
    if (currProject.type === 'repoRoot') return Try.success(currProject);
    const parentDir = path.resolve(currProject.rootPath, "..");
    return loadClosestUptreeProject(parentDir).match(
        _ => _.match(
            parentDirProject => getRepoRootProjectHelper(parentDirProject),
            () => Try.failure("No eggshell.json with `type` === `repoRoot` uptree from pwd.")
        ),
        error => Try.failure(error)
    );
}
