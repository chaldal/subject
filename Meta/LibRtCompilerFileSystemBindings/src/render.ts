import * as fs from "fs-extra";
import * as glob from "glob-promise";
import * as path from "path";
import { Seq, QQQ } from "eggshell-lib-lang-typescript";
import { fsPlus, childProcessPlus } from "eggshell-lib-node";
import { EggShellProject } from "eggshell-lib-eggshell";

import { deriveDestinationFilename, deriveComponentName, deriveRenderFilesGlobbingPattern, writeFileIfContentHasChanged } from "./filesPathsAndNames"

export async function recompileReactTemplate(project: EggShellProject, rtCompilerCmd: string, sourceFilename: string): Promise<void> {
    if (project.config.render == null) {
      return;
    }
    const additionalModulesToOpenSerialized = project.config.render.additionalModulesToOpen.join(";");
    const componentLibraryAliasesSerialized = project.config.render.componentLibraryAliases.map(_ => _.join("=")).join(";");
    const componentAliasesSerialized        = project.config.render.componentAliases.map(_ => _.join("=")).join(";");

    // wrapping additionalModulesToOpenSerialized in brackets because bash apparently skips "" and doesn't consider it an argument
    const command = `"${rtCompilerCmd}" Render "${deriveComponentName(sourceFilename)}" "${project.config.alias}" "[${additionalModulesToOpenSerialized}]" "${componentLibraryAliasesSerialized}" "${componentAliasesSerialized}"`;

    var sourceContents = await fs.readFile(sourceFilename, "utf8");

    // Remove any UTF-8 BOM. See https://github.com/nodejs/node-v0.x-archive/issues/1918#issuecomment-2480359.
    sourceContents = sourceContents.replace(/^\uFEFF/, '');

    // apparently in one of our projects, we have a .render file that generates more than the standard buffer size
    const { stdout, stderr } = await childProcessPlus.exec(command, {maxBuffer: 1024 * 1024}, sourceContents);

    if (stderr) {
        return Promise.reject(stderr);
    }
    else {
        const destinationFilename = deriveDestinationFilename(sourceFilename, project.srcPath, project.autogeneratedPath).replace(/\.render$/, ".Render.fs");

        try {
          fsPlus.ensureDirectoryExistsSync(destinationFilename);
        }
        catch (err) {
          if (err && err.code === "EEXIST") {
            // NO-OP, during parallel executions, race conditions are possible, and this
            // library function appears to be have been written by a n0ob who doesn't understand
            // concurrency.
            // Multiple render files are run in parallel for different files
            // (as the current compiler is designed to)
            // likely this function is internally implemented as:
            // if(!directoryExists) createDirectory
            // But the directory could gotten created in between two statements by a parallel
            // render process
          }
          else {
            throw err;
          }
        }

        const written =
          await writeFileIfContentHasChanged(destinationFilename, stdout)
            .catch(err => {
                return Promise.reject({
                    message: "Error in writing compiled react template file",
                    destinationFilename,
                    err,
                });
            });

        console.log(`${written ? "Compiled" : "Skipped"} ${sourceFilename}`);
    }
}

export async function processAllRender(project: EggShellProject, rtCompilerCmd: string): Promise<void> {
    console.log("Going to compile .render files...");
    const filenames = await glob(deriveRenderFilesGlobbingPattern(project.srcPath));
    await Promise.all(
        filenames.map(filename => {
            return recompileReactTemplate(project, rtCompilerCmd, filename);
        })
    );
}
